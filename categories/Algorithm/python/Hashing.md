# 해시법

데이터를 추가, 삭제를 할 때 효율적으로 수행할 수 있도록 하는 방법

각 해당 엘리먼트(키)에 대응 하는 해시값(일종의 인덱스)를 구하는 함수를 해시함수라고 하고,
해시 함수로 구한 값을 버킷이라고 한다.

- 해시 함수 : 키에 대응하는 해시값을 만드는 함수
- 해시 테이블 : 버킷

## 해시 충돌
키 : 해시값 = 1 : n 인 경우를 말한다.

## 해시 충돌을 해결하기 위한 방법
1. 체인법(오픈 해시법 open hashing)
2. 오픈 주소법 (closed hashing)

### 체인법
해시값이 같을 경우, 각 해시값이 같은 데이터를 연결리스트로 연결하는 것을 말한다.
- 장점 : 해시 테이블의 확장이 필요없다.
- 단점 : 계속해서 연결해서 리스트에 데이터를 추가하다보면 메모리 문제가 생긴다. 왜냐하면, 비어있는 버킷이 놀고 있게 된다. 그리고 탐색의 효율성이 떨어진다.

### 오픈 주소법
1. 빈 버킷,즉 해시에 대응하는 키가 없는 곳을 찾을 때까지 해싱을 반복하는 것.
2. 현재의 버킷으로부터 일정한 칸만큼 옮기는 것
3. 고정된 값의 제곱으로 옮기는 방법

closed hashing 이라고도 한다.

- 단점
    - 해시테이블 모두 차게 되면 확장해야한다.
    - 충돌이 많이 발생할 수록 해싱 계산으로 인해 시간복잡도가 증가한다.

## 적재율
버킷대비 key의 갯수
key의 개수 / 테이블의 크기

## 장점

삽입, 삭제, 검색에서 O(1)의 시간 복잡도를 가진다.
## 단점
데이터가 저장되기 전에 해시테이블 공간을 확보해야하므로 공간효율성이 떨어진다.
만약 새로 삽입 시에, 해시 테이블에서 전부 충돌했을 경우, O(n)의 시간 복잡도를 가진다. 이유는 해시테이블의 버킷수 N 만큼의 탐색을 해야하기 때문이다.

## 해시 테이블을 만들때

해시 테이블을 만들 때 충분히 크게 만들면 해시 충돌을 억제할 수 있지만, 시간과 공간의 상충관계가 생긴다.
충돌을 피하기 위한 효율적인 방법은, 해시 함수가 해시 테이블 크기보다 작거나 같은 정수를 고르도록 해야한다.
해시 테이블의 크기는 소수를 선호한다.

### 해시 테이블의 크기를 소수로 정하는 이유
균둥하게 해시테이블에 값을 나눠줄 수 있기 때문,
만약에 짝수이고 해시테이블의 2의 배수라면, 
해시값이 짝수인 경우, 혹은 나머지 1일 때 둘 중 하나의 버킷에 값이 쌓이게된다.
소수는 1과 자기자신만으로 나눌 수 있기 때문에 모듈러 연산을 한다면, 모든 버킷으로 고르게 값이 분배될 수 있다.

# 예시 
1. Set 데이터 구조 구현
2. 캐시
